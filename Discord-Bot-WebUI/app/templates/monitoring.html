<!-- templates/monitoring.html -->
{% extends "base.html" %}
{% block title %}Task Monitor{% endblock %}

{% block main_content %}
<div class="container-xxl flex-grow-1 container-p-y">
    <!-- Page Header -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="d-flex justify-content-between align-items-center flex-wrap gap-2">
                <div>
                    <h2 class="text-primary mb-1">System Monitoring</h2>
                    <p class="text-muted">Track scheduled tasks and system status</p>
                </div>
                <div class="d-flex align-items-center gap-2">
                    <span class="text-muted">Last Updated: <span id="lastUpdated"></span></span>
                    <button type="button" id="refreshButton" class="btn btn-icon btn-outline-primary btn-sm">
                        <i class="ti ti-refresh"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- System Health Overview -->
    <div class="row">
        <!-- Workers Status -->
        <div class="col-xl-3 col-lg-6 col-md-6 mb-4">
            <div class="card h-100">
                <div class="card-body">
                    <div class="d-flex justify-content-between">
                        <div class="card-info">
                            <h5 class="mb-0">Celery Workers</h5>
                            <small class="text-muted">Background task processors</small>
                        </div>
                        <div class="card-icon" id="workerStatusBadge">
                            <span class="badge bg-label-secondary rounded-pill">Checking...</span>
                        </div>
                    </div>
                    <div class="mt-2" id="workersList">
                        <!-- Workers will be populated here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Redis Status -->
        <div class="col-xl-3 col-lg-6 col-md-6 mb-4">
            <div class="card h-100">
                <div class="card-body">
                    <div class="d-flex justify-content-between">
                        <div class="card-info">
                            <h5 class="mb-0">Redis</h5>
                            <small class="text-muted">Task queue and cache</small>
                        </div>
                        <div class="card-icon">
                            <span id="redisConnectionStatus" class="badge bg-label-success rounded-pill">Connected</span>
                        </div>
                    </div>
                    <div class="mt-3">
                        <span class="badge bg-label-info rounded-pill mb-2">
                            <i class="ti ti-database me-1"></i><span id="redisKeysCount">0</span> Keys
                        </span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Scheduled Tasks -->
        <div class="col-xl-3 col-lg-6 col-md-6 mb-4">
            <div class="card h-100">
                <div class="card-body">
                    <div class="d-flex justify-content-between">
                        <div class="card-info">
                            <h5 class="mb-0">Scheduled Tasks</h5>
                            <small class="text-muted">Upcoming tasks</small>
                        </div>
                        <div class="card-icon">
                            <i class="ti ti-calendar-stats fs-3 text-primary"></i>
                        </div>
                    </div>
                    <h3 class="mt-2 pt-1 mb-0" id="totalTasks">0</h3>
                    <span class="badge bg-label-primary mb-0">
                        <i class="ti ti-clock me-1"></i>Pending: <span id="pendingTasks">0</span>
                    </span>
                </div>
            </div>
        </div>

        <!-- Task Status -->
        <div class="col-xl-3 col-lg-6 col-md-6 mb-4">
            <div class="card h-100">
                <div class="card-body">
                    <div class="d-flex justify-content-between">
                        <div class="card-info">
                            <h5 class="mb-0">Task Status</h5>
                            <small class="text-muted">Execution results</small>
                        </div>
                        <div class="card-icon">
                            <i class="ti ti-report fs-3 text-primary"></i>
                        </div>
                    </div>
                    <div class="mt-3 d-flex gap-2">
                        <span class="badge bg-label-success rounded-pill">
                            <i class="ti ti-check me-1"></i>Success: <span id="successfulTasks">0</span>
                        </span>
                        <span class="badge bg-label-danger rounded-pill">
                            <i class="ti ti-x me-1"></i>Failed: <span id="failedTasks">0</span>
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Admin Actions Card -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-body">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <h5 class="mb-0">Admin Actions</h5>
                    </div>
                    <div class="row g-3">
                        <div class="col-xl-3 col-md-6">
                            <button type="button" id="revokeAllButton" class="btn btn-danger btn-sm w-100">
                                <i class="ti ti-trash me-1"></i>Revoke All Tasks
                            </button>
                        </div>
                        <div class="col-xl-3 col-md-6">
                            <a href="{{ url_for('monitoring.db_monitoring') }}" class="btn btn-primary btn-sm w-100">
                                <i class="ti ti-database me-1"></i>Database Monitoring
                            </a>
                        </div>
                        <div class="col-xl-3 col-md-6">
                            <button type="button" class="btn btn-outline-primary btn-sm w-100" onclick="fetchData()">
                                <i class="ti ti-refresh me-1"></i>Refresh Data
                            </button>
                        </div>
                        <div class="col-xl-3 col-md-6">
                            <button type="button" id="cleanupOrphanedButton" class="btn btn-warning btn-sm w-100">
                                <i class="ti ti-robot me-1"></i>Clean Orphaned Tasks
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Loading and Error States -->
    <div id="loadingSpinner" class="d-flex justify-content-center align-items-center py-4 mb-4" style="display: none;">
        <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
    </div>

    <div id="errorAlert" class="alert alert-danger mb-4" style="display: none;">
        <div class="d-flex">
            <i class="ti ti-alert-circle me-2"></i>
            <div>
                <h6 class="alert-heading mb-1">Error</h6>
                <span id="errorMessage"></span>
            </div>
        </div>
    </div>

    <!-- Scheduled Tasks Card -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-header border-bottom">
                    <div class="d-flex justify-content-between align-items-center">
                        <h5 class="mb-0"><i class="ti ti-list-check me-2"></i>Scheduled Tasks</h5>
                        <span class="badge bg-label-primary ms-2" id="scheduledTasksCount">0 tasks</span>
                    </div>
                </div>
                <div class="card-body p-0">
                    <!-- Tasks Accordion -->
                    <div id="tasksAccordion" class="accordion accordion-flush">
                        <!-- Tasks will be populated here -->
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Worker Scheduled Tasks Card -->
    <div class="row mb-4" id="workerScheduledTasksRow" style="display: none;">
        <div class="col-12">
            <div class="card">
                <div class="card-header border-bottom">
                    <div class="d-flex justify-content-between align-items-center">
                        <h5 class="mb-0"><i class="ti ti-calendar-time me-2"></i>Worker Scheduled Tasks</h5>
                        <span class="badge bg-label-warning ms-2" id="workerScheduledTasksCount">0 tasks</span>
                    </div>
                </div>
                <div class="table-responsive">
                    <table class="table table-hover">
                        <thead class="table-light">
                            <tr>
                                <th>Worker</th>
                                <th>Task Name</th>
                                <th>Arguments/Match</th>
                                <th>ETA</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="workerScheduledTasksTable">
                            <!-- Worker scheduled tasks will be populated here -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- Worker Details Card -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-header border-bottom">
                    <div class="d-flex justify-content-between align-items-center">
                        <h5 class="mb-0"><i class="ti ti-servers me-2"></i>Worker Details</h5>
                    </div>
                </div>
                <div class="table-responsive">
                    <table class="table table-hover">
                        <thead class="table-light">
                            <tr>
                                <th>Worker Name</th>
                                <th>Status</th>
                                <th>Pool Size</th>
                                <th>Active Tasks</th>
                                <th>Registered Tasks</th>
                                <th>Scheduled</th>
                                <th>Reserved</th>
                            </tr>
                        </thead>
                        <tbody id="workersDetailTable">
                            <!-- Worker details will be populated here -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- Redis Task Entries Card -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-header border-bottom">
                    <div class="d-flex justify-content-between align-items-center">
                        <h5 class="mb-0"><i class="ti ti-database me-2"></i>Redis Task Entries</h5>
                        <span class="badge bg-label-info ms-2" id="redisEntriesCount">0 entries</span>
                    </div>
                </div>
                <div class="table-responsive">
                    <table class="table table-hover">
                        <thead class="table-light">
                            <tr>
                                <th>Key</th>
                                <th>Task ID</th>
                                <th>Status</th>
                                <th>Countdown</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="redisKeysTable">
                            <!-- Redis keys will be populated here -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- Task Action Modal -->
    <div class="modal fade" id="taskActionModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Task Action</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <p id="taskActionMessage"></p>
                    <div class="alert alert-warning">
                        <div class="d-flex">
                            <i class="ti ti-alert-triangle me-2"></i>
                            <div>This action cannot be undone.</div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-danger" id="confirmTaskAction">Confirm</button>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block custom_css %}
<style>
    /* Status badges */
    .badge.rounded-pill {
        padding: 0.5rem 0.75rem;
    }
    
    /* Task accordion styling */
    .accordion-button:not(.collapsed) {
        color: var(--bs-primary);
        background-color: rgba(var(--bs-primary-rgb), 0.1);
    }
    
    .accordion-button:focus {
        box-shadow: none;
        border-color: rgba(0, 0, 0, 0.125);
    }
    
    /* Section styling */
    .card-icon {
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    /* Empty state styling */
    .empty-state {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 2rem;
        text-align: center;
    }
    
    .empty-state-icon {
        font-size: 3rem;
        color: var(--bs-secondary);
        margin-bottom: 1rem;
    }
    
    /* Timeline for tasks */
    .match-timeline {
        position: relative;
        padding-left: 2rem;
    }
    
    .match-timeline:before {
        content: '';
        position: absolute;
        top: 0;
        left: 0.75rem;
        height: 100%;
        width: 2px;
        background-color: #e9ecef;
    }
    
    .match-timeline-item {
        position: relative;
        padding-bottom: 1.5rem;
    }
    
    .match-timeline-item:last-child {
        padding-bottom: 0;
    }
    
    .timeline-point {
        position: absolute;
        left: -2rem;
        width: 1.5rem;
        height: 1.5rem;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
    }
    
    /* Status colors for timeline */
    .status-pending {
        background-color: var(--bs-warning);
    }
    
    .status-success {
        background-color: var(--bs-success);
    }
    
    .status-failure {
        background-color: var(--bs-danger);
    }
    
    .status-unknown {
        background-color: var(--bs-info);
    }
    
    .status-error {
        background-color: var(--bs-danger);
    }
    
    /* Task details styling */
    .task-details-table {
        font-size: 0.85rem;
    }
    
    .task-details-table td {
        padding: 0.3rem;
        vertical-align: top;
    }
    
    .task-info {
        max-height: 200px;
        overflow-y: auto;
        background-color: var(--bs-light);
        padding: 0.5rem;
        border-radius: 0.25rem;
        font-family: monospace;
        font-size: 0.85rem;
    }
    
    /* Worker status styling */
    #workersList {
        max-height: 120px;
        overflow-y: auto;
    }
    
    /* Prevent layout jumps during reloads */
    .card {
        transition: min-height 0.3s ease-out;
    }
    
    .table-responsive {
        transition: min-height 0.3s ease-out;
    }
    
    /* Add visual indicators to countdown */
    .countdown-warning {
        color: var(--bs-warning);
        font-weight: 500;
    }
    
    .countdown-critical {
        color: var(--bs-danger);
        font-weight: 700;
        animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
        0% { opacity: 1; }
        50% { opacity: 0.7; }
        100% { opacity: 1; }
    }
    
    /* Media queries for responsive design */
    @media (max-width: 767.98px) {
        .match-timeline {
            padding-left: 1.5rem;
        }
        
        .timeline-point {
            left: -1.5rem;
            width: 1.25rem;
            height: 1.25rem;
            font-size: 0.75rem;
        }
    }
</style>
{% endblock %}

{% block custom_js %}
<script>
    // Get CSRF token from meta tag
    const csrfToken = document.querySelector('meta[name="csrf-token"]').getAttribute('content');

    // Configure jQuery to send CSRF token on every AJAX request.
    $.ajaxSetup({
        headers: {
            'X-CSRFToken': csrfToken
        }
    });

    // Utility: Convert seconds to HH:MM:SS format
    function secondsToHMS(seconds) {
        if (seconds === null || seconds === undefined || isNaN(seconds)) {
            return "N/A";
        }
        const h = Math.floor(seconds / 3600);
        const m = Math.floor((seconds % 3600) / 60);
        const s = Math.floor(seconds % 60);
        return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    }

    // Utility: Format ISO date string into local date/time string
    function formatLocalDate(isoDate) {
        if (!isoDate) return 'N/A';
        const d = new Date(isoDate);
        return d.toLocaleString();
    }

    // Format relative time
    function formatRelativeTime(isoDate) {
        if (!isoDate) return 'N/A';
        
        const now = new Date();
        const date = new Date(isoDate);
        const diffMs = date - now;
        const diffSec = Math.floor(diffMs / 1000);
        
        if (diffSec < 0) {
            // In the past
            const absDiff = Math.abs(diffSec);
            if (absDiff < 60) return 'Just now';
            if (absDiff < 3600) return `${Math.floor(absDiff / 60)} minutes ago`;
            if (absDiff < 86400) return `${Math.floor(absDiff / 3600)} hours ago`;
            return `${Math.floor(absDiff / 86400)} days ago`;
        } else {
            // In the future
            if (diffSec < 60) return 'In less than a minute';
            if (diffSec < 3600) return `In ${Math.floor(diffSec / 60)} minutes`;
            if (diffSec < 86400) return `In ${Math.floor(diffSec / 3600)} hours`;
            return `In ${Math.floor(diffSec / 86400)} days`;
        }
    }

    // Create match details HTML
    function createMatchDetails(details) {
        // Ensure we have details to work with
        if (!details) return '<div class="card mb-3"><div class="card-body">No match details available</div></div>';
        
        return `
        <div class="card mb-3">
            <div class="card-header border-bottom">
                <h6 class="card-title mb-0">Match Details</h6>
            </div>
            <div class="card-body">
                <div class="row g-3">
                    <div class="col-md-6">
                        <div class="d-flex align-items-center">
                            <div class="avatar avatar-sm bg-label-primary me-2">
                                <i class="ti ti-users"></i>
                            </div>
                            <div>
                                <span class="fw-medium">Opponent</span>
                                <p class="text-muted mb-0">${details.opponent || 'Unknown'}</p>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="d-flex align-items-center">
                            <div class="avatar avatar-sm bg-label-info me-2">
                                <i class="ti ti-calendar"></i>
                            </div>
                            <div>
                                <span class="fw-medium">Match Time</span>
                                <p class="text-muted mb-0">${formatLocalDate(details.date_time)}</p>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="d-flex align-items-center">
                            <div class="avatar avatar-sm bg-label-warning me-2">
                                <i class="ti ti-message-circle"></i>
                            </div>
                            <div>
                                <span class="fw-medium">Thread Creation</span>
                                <p class="text-muted mb-0">${details.thread_creation_time ? formatLocalDate(details.thread_creation_time) : 'Not scheduled'}</p>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="d-flex align-items-center">
                            <div class="avatar avatar-sm bg-label-success me-2">
                                <i class="ti ti-message-report"></i>
                            </div>
                            <div>
                                <span class="fw-medium">Live Reporting</span>
                                <p class="text-muted mb-0">${details.live_reporting_scheduled ? 'Scheduled' : 'Not scheduled'}</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>`;
    }

    // State management
    let taskData = {};
    let redisData = {};

    // DOM Elements
    const totalTasksEl = document.getElementById('totalTasks');
    const pendingTasksEl = document.getElementById('pendingTasks');
    const successfulTasksEl = document.getElementById('successfulTasks');
    const failedTasksEl = document.getElementById('failedTasks');
    const lastUpdatedEl = document.getElementById('lastUpdated');
    const loadingSpinner = document.getElementById('loadingSpinner');
    const errorAlert = document.getElementById('errorAlert');
    const errorMessage = document.getElementById('errorMessage');
    const tasksAccordion = document.getElementById('tasksAccordion');
    const redisConnectionStatus = document.getElementById('redisConnectionStatus');
    const redisKeysTable = document.getElementById('redisKeysTable');
    const redisKeysCount = document.getElementById('redisKeysCount');
    const refreshButton = document.getElementById('refreshButton');
    const revokeAllButton = document.getElementById('revokeAllButton');

    // Fetch data from endpoints
    async function fetchData() {
        try {
            loadingSpinner.style.display = 'flex';
            errorAlert.style.display = 'none';

            // Get container heights before fetching data to avoid layout shifts
            const containers = document.querySelectorAll('.card, .table-responsive');
            containers.forEach(container => {
                if (container.offsetHeight > 0) {
                    container.style.minHeight = `${container.offsetHeight}px`;
                }
            });

            const [tasksResponse, redisResponse, workersResponse] = await Promise.all([
                fetch('{{ url_for("monitoring.get_all_tasks") }}'),
                fetch('{{ url_for("monitoring.get_redis_keys") }}'),
                fetch('{{ url_for("monitoring.get_workers") }}')
            ]);

            const tasksData = await tasksResponse.json();
            const redisKeysData = await redisResponse.json();
            const workersData = await workersResponse.json();

            if (tasksData.success && redisKeysData.success) {
                updateDashboard(tasksData, redisKeysData, workersData);
                lastUpdatedEl.textContent = new Date().toLocaleTimeString();
            } else {
                throw new Error('Failed to fetch monitoring data');
            }
        } catch (err) {
            showError(err.message);
        } finally {
            loadingSpinner.style.display = 'none';
            
            // Reset container heights after data is loaded
            setTimeout(() => {
                const containers = document.querySelectorAll('.card, .table-responsive');
                containers.forEach(container => {
                    container.style.minHeight = '';
                });
            }, 500);
        }
    }

    // Update dashboard with new data
    function updateDashboard(tasks, redis, workers) {
        taskData = tasks;
        redisData = redis;
        
        // Store workers data for cross-referencing
        window.lastWorkerData = workers;

        // Update summary counts
        let counts = calculateTaskCounts(tasks);
        totalTasksEl.textContent = counts.total;
        pendingTasksEl.textContent = counts.pending;
        successfulTasksEl.textContent = counts.successful;
        failedTasksEl.textContent = counts.failed;

        // Update tasks accordion
        updateTasksAccordion(tasks);

        // Update Redis keys table
        updateRedisKeysTable(redis);

        // Update Redis connection status
        updateRedisStatus(redis);
        
        // Update workers information
        updateWorkersInfo(workers);
    }
    
    // Update worker information
    function updateWorkersInfo(workersData) {
        if (!workersData || !workersData.success) {
            document.getElementById('workerStatusBadge').innerHTML = `
                <span class="badge bg-label-danger rounded-pill">Error</span>
            `;
            document.getElementById('workersList').innerHTML = `
                <div class="alert alert-danger mt-2 mb-0">
                    <small>Could not fetch worker information</small>
                </div>
            `;
            document.getElementById('workersDetailTable').innerHTML = `
                <tr>
                    <td colspan="7" class="text-center py-3">
                        Error fetching worker information
                    </td>
                </tr>
            `;
            return;
        }
        
        // Update worker badge in summary card
        const totalWorkers = workersData.total_workers || 0;
        const activeWorkers = workersData.active_workers || 0;
        const statusColor = activeWorkers > 0 ? 'success' : 'danger';
        const statusText = activeWorkers > 0 ? 'Online' : 'Offline';
        
        document.getElementById('workerStatusBadge').innerHTML = `
            <span class="badge bg-label-${statusColor} rounded-pill">${statusText} (${activeWorkers}/${totalWorkers})</span>
        `;
        
        // Update scheduled tasks count in the dashboard
        const totalScheduledTasks = workersData.total_scheduled_tasks || 0;
        const pendingTasksEl = document.getElementById('pendingTasks');
        const totalTasksEl = document.getElementById('totalTasks');
        const scheduledTasksCountEl = document.getElementById('scheduledTasksCount');
        
        // Update task counts to reflect what's coming from workers API
        if (pendingTasksEl && totalTasksEl) {
            // Only update if there are scheduled tasks but none are shown in UI
            if (totalScheduledTasks > 0 && pendingTasksEl.textContent === '0') {
                pendingTasksEl.textContent = totalScheduledTasks;
                totalTasksEl.textContent = totalScheduledTasks;
            }
        }
        
        // Update scheduled tasks count in card header
        if (scheduledTasksCountEl) {
            scheduledTasksCountEl.textContent = `${taskData.matches ? Object.keys(taskData.matches).length : 0} tasks`;
        }
        
        // Update worker list in summary card
        const workersList = document.getElementById('workersList');
        if (!workersData.workers || Object.keys(workersData.workers).length === 0) {
            workersList.innerHTML = `
                <div class="alert alert-warning mt-2 mb-0">
                    <small>No active workers detected</small>
                </div>
            `;
        } else {
            let totalScheduled = 0;
            Object.values(workersData.workers).forEach(data => {
                totalScheduled += data.scheduled_tasks || 0;
            });
            
            let workersListHtml = '';
            Object.entries(workersData.workers).forEach(([name, data], index) => {
                if (index < 3) {  // Show first 3 workers in summary card
                    const statusColor = data.status === 'online' ? 'success' : 'danger';
                    const taskBadge = data.scheduled_tasks > 0 ? 
                        `<span class="badge bg-label-warning ms-1" title="${data.scheduled_tasks} scheduled tasks">
                            <small>${data.scheduled_tasks}</small>
                        </span>` : '';
                        
                    workersListHtml += `
                        <div class="d-flex align-items-center mt-2">
                            <span class="badge bg-${statusColor} rounded-pill me-2" style="width: 8px; height: 8px; padding: 0;"></span>
                            <small class="text-truncate">${name}</small>
                            <div class="ms-auto d-flex align-items-center">
                                <span class="badge bg-label-${statusColor}">
                                    <small>${data.active_tasks.length} active</small>
                                </span>
                                ${taskBadge}
                            </div>
                        </div>
                    `;
                }
            });
            
            // Show summary of all scheduled tasks across workers
            if (totalScheduled > 0) {
                workersListHtml += `
                    <div class="alert alert-warning mt-2 mb-0 py-1">
                        <small><strong>${totalScheduled}</strong> scheduled task${totalScheduled !== 1 ? 's' : ''} across all workers</small>
                    </div>
                `;
            }
            
            if (Object.keys(workersData.workers).length > 3) {
                workersListHtml += `
                    <div class="text-end mt-2">
                        <small class="text-muted">+${Object.keys(workersData.workers).length - 3} more workers</small>
                    </div>
                `;
            }
            
            workersList.innerHTML = workersListHtml;
        }
        
        // Update detailed workers table
        const workersDetailTable = document.getElementById('workersDetailTable');
        if (!workersData.workers || Object.keys(workersData.workers).length === 0) {
            workersDetailTable.innerHTML = `
                <tr>
                    <td colspan="7" class="text-center py-3">
                        <div class="empty-state py-4">
                            <div class="empty-state-icon">
                                <i class="ti ti-server-off"></i>
                            </div>
                            <h6 class="mt-1">No Active Workers</h6>
                            <p class="text-muted">There are currently no Celery workers active.</p>
                        </div>
                    </td>
                </tr>
            `;
        } else {
            let detailHtml = '';
            Object.entries(workersData.workers).forEach(([name, data]) => {
                const statusColor = data.status === 'online' ? 'success' : 'danger';
                const poolSize = workersData.queues && workersData.queues[name] ? workersData.queues[name].pool_size : 'N/A';
                
                // Highlight if scheduled tasks exist
                const scheduledClass = data.scheduled_tasks > 0 ? 'fw-bold text-warning' : '';
                
                detailHtml += `
                    <tr>
                        <td>
                            <div class="d-flex align-items-center">
                                <span class="badge bg-${statusColor} rounded-pill me-2" style="width: 8px; height: 8px; padding: 0;"></span>
                                <span>${name}</span>
                            </div>
                        </td>
                        <td><span class="badge bg-label-${statusColor}">${data.status}</span></td>
                        <td>${poolSize}</td>
                        <td>${data.active_tasks.length}</td>
                        <td>${data.registered_tasks}</td>
                        <td class="${scheduledClass}">${data.scheduled_tasks}</td>
                        <td>${data.reserved_tasks}</td>
                    </tr>
                `;
            });
            
            // Add a summary row
            const totalRegistered = Object.values(workersData.workers).reduce((sum, data) => sum + data.registered_tasks, 0);
            const totalScheduled = Object.values(workersData.workers).reduce((sum, data) => sum + data.scheduled_tasks, 0);
            const totalReserved = Object.values(workersData.workers).reduce((sum, data) => sum + data.reserved_tasks, 0);
            const totalActive = Object.values(workersData.workers).reduce((sum, data) => sum + data.active_tasks.length, 0);
            
            detailHtml += `
                <tr class="table-light">
                    <td colspan="3" class="text-end"><strong>Totals:</strong></td>
                    <td><strong>${totalActive}</strong></td>
                    <td><strong>${totalRegistered}</strong></td>
                    <td class="${totalScheduled > 0 ? 'text-warning' : ''}"><strong>${totalScheduled}</strong></td>
                    <td><strong>${totalReserved}</strong></td>
                </tr>
            `;
            
            workersDetailTable.innerHTML = detailHtml;
        }
        
        // Process scheduled tasks from workers data
        updateWorkerScheduledTasks(workersData);
        
        // Show error message if provided in response
        if (workersData.error) {
            showError(workersData.error);
        }
    }
    
    // Update worker scheduled tasks table
    function updateWorkerScheduledTasks(workersData) {
        const scheduledTasks = workersData.scheduled_tasks || [];
        const workerScheduledTasksRow = document.getElementById('workerScheduledTasksRow');
        const workerScheduledTasksTable = document.getElementById('workerScheduledTasksTable');
        const workerScheduledTasksCount = document.getElementById('workerScheduledTasksCount');
        
        // Hide the row if no scheduled tasks
        if (scheduledTasks.length === 0) {
            workerScheduledTasksRow.style.display = 'none';
            return;
        }
        
        // Show the row and update count
        workerScheduledTasksRow.style.display = '';
        workerScheduledTasksCount.textContent = `${scheduledTasks.length} tasks`;
        
        // Build the table
        let scheduledTasksHtml = '';
        scheduledTasks.forEach(task => {
            const taskName = task.name || 'Unknown Task';
            const simpleTaskName = taskName.split('.')
                .pop()
                .replace(/_/g, ' ')
                .replace(/([A-Z])/g, ' $1')
                .trim(); // Cleaner name for display
                
            // Format args as string
            let argsStr = '';
            if (task.args && task.args.length > 0) {
                argsStr = task.args.join(', ');
            }
            
            // Format kwargs as string
            if (task.kwargs && Object.keys(task.kwargs).length > 0) {
                const kwargsArr = Object.entries(task.kwargs).map(([k, v]) => `${k}=${JSON.stringify(v)}`);
                if (argsStr) {
                    argsStr += ', ' + kwargsArr.join(', ');
                } else {
                    argsStr = kwargsArr.join(', ');
                }
            }
            
            // Truncate args if too long
            if (argsStr.length > 50) {
                argsStr = argsStr.substring(0, 47) + '...';
            }
            
            // Format ETA
            let etaFormatted = 'N/A';
            if (task.eta) {
                const etaDate = new Date(task.eta);
                etaFormatted = etaDate.toLocaleString();
                
                // Add countdown if in the future
                const now = new Date();
                const diffMs = etaDate - now;
                if (diffMs > 0) {
                    const diffSec = Math.floor(diffMs / 1000);
                    let countdownClass = '';
                    
                    if (diffSec < 300) { // less than 5 minutes
                        countdownClass = 'countdown-critical';
                    } else if (diffSec < 1800) { // less than 30 minutes
                        countdownClass = 'countdown-warning';
                    }
                    
                    const countdown = secondsToHMS(diffSec);
                    etaFormatted += `<div class="${countdownClass} mt-1">In ${countdown}</div>`;
                }
            }
            
            // Format match details if available
            let matchDetails = '';
            if (task.match_details) {
                let matchDate = 'Unknown date';
                try {
                    if (task.match_details.date_time) {
                        matchDate = new Date(task.match_details.date_time).toLocaleString();
                    }
                } catch (e) {
                    console.error("Error parsing date:", e);
                }
                
                matchDetails = `
                    <div class="alert alert-info mt-2 p-2">
                        <strong>Match:</strong> ${task.match_details.opponent || 'Unknown'}<br>
                        <strong>Date:</strong> ${matchDate}<br>
                        <strong>Location:</strong> ${task.match_details.location || 'Unknown'}
                    </div>
                `;
            }
            
            // Try to guess task purpose from the name
            let taskPurpose = 'Unknown purpose';
            if (taskName.includes('thread')) {
                taskPurpose = 'Create Discord Thread';
            } else if (taskName.includes('live_reporting')) {
                taskPurpose = 'Start Live Reporting';
            } else if (taskName.includes('rsvp')) {
                taskPurpose = 'Send RSVP Notification';
            } else if (taskName.includes('reminder')) {
                taskPurpose = 'Send Reminder';
            } else if (taskName.includes('clean')) {
                taskPurpose = 'Cleanup Task';
            }
            
            // Generate the row
            scheduledTasksHtml += `
                <tr>
                    <td>${task.worker}</td>
                    <td>
                        <div>
                            <strong>${taskPurpose}</strong>
                            <div><small class="text-muted">${simpleTaskName}</small></div>
                            <div><small class="text-muted text-truncate d-block" style="max-width: 300px;">${taskName}</small></div>
                            <div><small class="text-muted">Queue: ${task.queue || 'default'}</small></div>
                            ${task.id ? `<div><small class="text-muted">ID: ${task.id}</small></div>` : ''}
                        </div>
                    </td>
                    <td>
                        <code>${argsStr || 'None'}</code>
                        ${task.match_id ? `<div><small class="text-primary">Match ID: ${task.match_id}</small></div>` : ''}
                        ${matchDetails}
                        <button class="btn btn-sm btn-outline-secondary mt-1" 
                                onclick="showTaskDetails('${task.full_details ? task.full_details.replace(/'/g, "").replace(/"/g, "") : ""}')"
                                title="Show full task details">
                            <i class="ti ti-code me-1"></i>Details
                        </button>
                    </td>
                    <td>${etaFormatted}</td>
                    <td>
                        <div class="btn-group">
                            <button class="btn btn-sm btn-danger" onclick="revokeAllTasksForWorker('${task.worker}')">
                                <i class="ti ti-trash me-1"></i>Revoke All Tasks
                            </button>
                            ${task.match_id ? `
                            <button class="btn btn-sm btn-warning" onclick="findMatch('${task.match_id}')">
                                <i class="ti ti-search me-1"></i>Find Match
                            </button>
                            ` : ''}
                        </div>
                    </td>
                </tr>
            `;
        });
        
        workerScheduledTasksTable.innerHTML = scheduledTasksHtml;
    }

    // Calculate task counts
    function calculateTaskCounts(tasks) {
        let counts = { total: 0, pending: 0, successful: 0, failed: 0 };

        if (tasks && tasks.matches) {
            Object.values(tasks.matches).forEach(match => {
                ['thread_task', 'reporting_task'].forEach(taskType => {
                    const task = match[taskType];
                    if (task && task.status) {
                        // Count all tasks, even those with null status
                        counts.total++;
                        updateTaskCount(counts, task.status);
                    }
                });
            });
        }
        
        // If we have worker data with scheduled tasks, include them in the counts
        if (window.lastWorkerData && window.lastWorkerData.total_scheduled_tasks > 0) {
            // If we found no tasks via the task API but we know there are scheduled tasks
            // from the worker API, use those counts instead
            if (counts.total === 0) {
                counts.total = window.lastWorkerData.total_scheduled_tasks;
                counts.pending = window.lastWorkerData.total_scheduled_tasks;
            }
        }

        return counts;
    }

    function updateTaskCount(counts, status) {
        if (!status) return; // Skip if status is null
        
        // Ensure status is a string and convert to uppercase for consistent comparison
        const statusStr = String(status).toUpperCase();
        
        switch (statusStr) {
            case 'PENDING':
                counts.pending++;
                break;
            case 'SUCCESS':
                counts.successful++;
                break;
            case 'FAILURE':
                counts.failed++;
                break;
            default:
                // Count unknown statuses as pending for the summary
                counts.pending++;
                break;
        }
    }

    // Update tasks accordion
    function updateTasksAccordion(tasks) {
        tasksAccordion.innerHTML = '';

        if (!tasks || !tasks.matches || Object.keys(tasks.matches).length === 0) {
            tasksAccordion.innerHTML = `
            <div class="empty-state py-5">
                <div class="empty-state-icon">
                    <i class="ti ti-calendar-off"></i>
                </div>
                <h6 class="mt-1">No Scheduled Tasks</h6>
                <p class="text-muted">There are currently no tasks scheduled in the system.</p>
            </div>`;
            return;
        }

        Object.entries(tasks.matches).forEach(([matchId, matchData]) => {
            const accordionItem = createAccordionItem(matchId, matchData);
            tasksAccordion.appendChild(accordionItem);
        });
    }

    // Create accordion item for a match
    function createAccordionItem(matchId, matchData) {
        // If additional match details exist, display them in the header
        let headerText = `Match ${matchId}`;
        if (matchData && matchData.match_details) {
            headerText = `Match: ${matchData.match_details.opponent || 'Unknown'}`;
        }
        
        const div = document.createElement('div');
        div.className = 'accordion-item';
        div.innerHTML = `
        <h2 class="accordion-header">
            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                    data-bs-target="#match-${matchId}">
                <div class="d-flex align-items-center flex-grow-1">
                    <div class="avatar avatar-sm bg-label-primary me-2">
                        <i class="ti ti-soccer-field"></i>
                    </div>
                    <div>
                        <span class="fw-medium">${headerText}</span>
                        <div class="d-flex align-items-center gap-1 mt-1">
                            ${getStatusBadges(matchData)}
                        </div>
                    </div>
                </div>
            </button>
        </h2>
        <div id="match-${matchId}" class="accordion-collapse collapse">
            <div class="accordion-body">
                <div class="row">
                    <div class="col-xl-6 col-lg-12 mb-4">
                        ${createTaskDetails(matchData)}
                    </div>
                    <div class="col-xl-6 col-lg-12">
                        ${matchData.match_details ? createMatchDetails(matchData.match_details) : ''}
                    </div>
                </div>
            </div>
        </div>`;
        return div;
    }

    // Create status badges for tasks
    function getStatusBadges(matchData) {
        if (!matchData) return '';
        let badges = '';

        // Thread task badge
        if (matchData.thread_task) {
            const status = matchData.thread_task.status ? String(matchData.thread_task.status) : 'PENDING';
            badges += `<span class="badge bg-label-${getStatusColor(status)}">
                <i class="ti ti-message-circle me-1"></i>Thread: ${status}
            </span>`;
        } else {
            badges += `<span class="badge bg-label-secondary">
                <i class="ti ti-message-circle me-1"></i>Thread: Not Scheduled
            </span>`;
        }

        // Reporting task badge
        if (matchData.reporting_task) {
            const status = matchData.reporting_task.status ? String(matchData.reporting_task.status) : 'PENDING';
            badges += `<span class="badge bg-label-${getStatusColor(status)}">
                <i class="ti ti-report me-1"></i>Reporting: ${status}
            </span>`;
        } else {
            badges += `<span class="badge bg-label-secondary">
                <i class="ti ti-report me-1"></i>Reporting: Not Scheduled
            </span>`;
        }

        return badges;
    }

    // Get appropriate color for status
    function getStatusColor(status) {
        if (status === null || status === undefined) return 'secondary';
        
        // Ensure status is a string
        const statusStr = String(status).toUpperCase();
        
        switch (statusStr) {
            case 'SUCCESS':
                return 'success';
            case 'PENDING':
                return 'warning';
            case 'STARTED':
                return 'info';
            case 'RETRY':
                return 'warning';
            case 'FAILURE':
            case 'ERROR':
                return 'danger';
            case 'REVOKED':
                return 'secondary';
            case 'UNKNOWN':
                return 'info';
            default:
                return 'secondary';
        }
    }

    // Create detailed task information for tasks
    function createTaskDetails(matchData) {
        if (!matchData) return '<div>No task details available</div>';
        
        let html = '<div class="match-timeline">';

        if (matchData.thread_task) {
            html += createTaskSection('Thread Creation Task', matchData.thread_task, 'message-circle');
        }

        if (matchData.reporting_task) {
            html += createTaskSection('Live Reporting Task', matchData.reporting_task, 'report');
        }

        html += '</div>';
        return html;
    }

    // Create a section for an individual task
    function createTaskSection(title, task, icon) {
        if (!task) {
            return `
            <div class="match-timeline-item">
                <div class="timeline-point status-unknown">
                    <i class="ti ti-help text-white"></i>
                </div>
                <div class="card">
                    <div class="card-header">
                        <h6 class="mb-0"><i class="ti ti-${icon} me-1"></i>${title}</h6>
                    </div>
                    <div class="card-body">
                        <p>No task information available</p>
                    </div>
                </div>
            </div>`;
        }
        
        // Default status if null
        const status = task.status ? String(task.status) : 'PENDING';
        
        // Set task type based on title
        const taskType = title.toLowerCase().includes('thread') ? 'thread' : 'reporting';
        
        // Ensure task has match_id by examining key or match_key
        let matchId = '';
        if (task.match_key) {
            // Extract match ID from key format like "match_scheduler:12345:thread"
            const parts = task.match_key.split(':');
            if (parts.length >= 2) {
                matchId = parts[1];
            }
        }
        
        // Get match ID from parent object if not found in key
        if (!matchId && task.match_id) {
            matchId = task.match_id;
        }
        
        const statusIconMap = {
            'PENDING': 'clock',
            'SUCCESS': 'check',
            'FAILURE': 'x',
            'UNKNOWN': 'help'
        };
        
        // Convert status to uppercase for consistent mapping
        const statusUpper = status.toUpperCase();
        const statusIcon = statusIconMap[statusUpper] || 'clock';
        const statusClass = statusUpper === 'UNKNOWN' ? 'pending' : status.toLowerCase();
        
        // Format task info for display
        let taskInfoHtml = '';
        if (task.info) {
            if (typeof task.info === 'object') {
                // Format object data as key-value pairs
                taskInfoHtml = `
                <div class="col-md-12">
                    <small class="text-muted d-block">Task Details</small>
                    <div class="mt-1 text-muted">
                        <table class="table table-sm table-borderless mb-0">
                            <tbody>`;
                
                // Add each property to the table
                for (const [key, value] of Object.entries(task.info)) {
                    // Skip null or undefined values
                    if (value === null || value === undefined) continue;
                    
                    // Format the value based on type
                    let displayValue = value;
                    if (typeof value === 'object') {
                        try {
                            displayValue = JSON.stringify(value);
                        } catch (e) {
                            displayValue = String(value);
                        }
                    }
                    
                    taskInfoHtml += `
                    <tr>
                        <td style="width: 30%;"><small>${key}:</small></td>
                        <td><small class="text-truncate d-inline-block" style="max-width: 250px;">${displayValue}</small></td>
                    </tr>`;
                }
                
                taskInfoHtml += `
                            </tbody>
                        </table>
                    </div>
                </div>`;
            } else {
                // Simple string display
                taskInfoHtml = `
                <div class="col-md-12">
                    <small class="text-muted d-block">Info</small>
                    <span>${task.info}</span>
                </div>`;
            }
        }
        
        // Store task type and match ID for use in the buttons
        task.task_type = taskType;
        task.match_id = matchId;
        
        return `
        <div class="match-timeline-item">
            <div class="timeline-point status-${statusClass}">
                <i class="ti ti-${statusIcon} text-white"></i>
            </div>
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h6 class="mb-0">
                        <i class="ti ti-${icon} me-1"></i>${title}
                    </h6>
                    <span class="badge bg-${getStatusColor(status)}">
                        ${status}
                    </span>
                </div>
                <div class="card-body">
                    <div class="row g-3">
                        <div class="col-md-6">
                            <small class="text-muted d-block">Task ID</small>
                            <span class="d-block text-truncate" style="max-width: 200px;">${task.id || 'N/A'}</span>
                        </div>
                        <div class="col-md-6">
                            <small class="text-muted d-block">Countdown</small>
                            <span>${task.ttl !== null && task.ttl !== undefined ? secondsToHMS(task.ttl) : 'N/A'}</span>
                        </div>
                        ${taskInfoHtml}
                        <!-- Hidden details for debugging -->
                        <div class="col-md-12">
                            <small class="text-muted d-block">Redis Key</small>
                            <span class="d-block text-truncate" style="max-width: 100%;">match_scheduler:${matchId}:${taskType}</span>
                        </div>
                    </div>
                    <div class="d-flex gap-2 mt-3">
                        <button class="btn btn-sm btn-danger" onclick="revokeTask('${task.id || ''}', 'match_scheduler:${matchId}:${taskType}')">
                            <i class="ti ti-trash me-1"></i>Revoke
                        </button>
                        <button class="btn btn-sm btn-warning" onclick="rescheduleTask('${task.id || ''}', 'match_scheduler:${matchId}:${taskType}')">
                            <i class="ti ti-refresh me-1"></i>Reschedule
                        </button>
                    </div>
                </div>
            </div>
        </div>`;
    }

    // Update Redis keys table
    function updateRedisKeysTable(redis) {
        redisKeysTable.innerHTML = '';
        redisKeysCount.textContent = redis && redis.total ? redis.total : 0;
        
        // Update Redis entries count in the header
        const entriesCount = document.getElementById('redisEntriesCount');
        if (entriesCount) {
            const count = redis && redis.keys ? Object.keys(redis.keys).length : 0;
            entriesCount.textContent = `${count} ${count === 1 ? 'entry' : 'entries'}`;
        }

        if (!redis || !redis.keys || Object.keys(redis.keys).length === 0) {
            redisKeysTable.innerHTML = `
            <tr>
                <td colspan="5" class="text-center py-4">
                    <div class="empty-state">
                        <i class="ti ti-database-off empty-state-icon"></i>
                        <h6 class="mt-1">No Redis Keys</h6>
                        <p class="text-muted">No task entries found in Redis.</p>
                    </div>
                </td>
            </tr>`;
            return;
        }

        // Sort keys by time-to-live (TTL) ascending
        const sortedEntries = Object.entries(redis.keys).sort((a, b) => {
            const ttlA = a[1]?.ttl || Number.MAX_SAFE_INTEGER;
            const ttlB = b[1]?.ttl || Number.MAX_SAFE_INTEGER;
            return ttlA - ttlB;
        });

        sortedEntries.forEach(([key, value]) => {
            const row = createRedisKeyRow(key, value);
            redisKeysTable.appendChild(row);
        });
    }

    // Create table row for Redis key
    function createRedisKeyRow(key, data) {
        if (!data) {
            return document.createElement('tr');
        }
        
        const tr = document.createElement('tr');
        let stored = data.value || 'N/A';
        let taskId = stored;
        let eta = null;
        
        // Attempt to parse the stored value as JSON to extract task ID and ETA
        if (typeof stored === 'string') {
            try {
                const obj = JSON.parse(stored);
                taskId = obj.task_id;
                eta = obj.eta;
            } catch (e) {
                taskId = stored;
            }
        }

        let countdown = 'N/A';
        if (eta) {
            const etaDate = new Date(eta);
            const now = new Date();
            let diff = Math.floor((etaDate - now) / 1000);
            if (diff < 0) diff = 0;
            countdown = secondsToHMS(diff);
        }

        // Safely extract task status
        let taskStatus = 'PENDING';
        if (data && data.task_status && data.task_status.status) {
            taskStatus = String(data.task_status.status);
        }
        
        // Format countdown with visual indicators
        let countdownHtml = countdown;
        if (data.ttl !== undefined && data.ttl !== null) {
            let countdownClass = '';
            if (data.ttl < 300) { // less than 5 minutes
                countdownClass = 'countdown-critical';
            } else if (data.ttl < 1800) { // less than 30 minutes
                countdownClass = 'countdown-warning';
            }
            
            if (countdownClass) {
                countdownHtml = `<span class="${countdownClass}">${countdown}</span>`;
            }
        }
        
        // Extract task name and match ID from key if available
        let taskName = '';
        let matchId = '';
        if (key && key.includes(':')) {
            const parts = key.split(':');
            if (parts.length >= 3) {
                matchId = parts[1];
                taskName = parts[2]; // The task type (thread or reporting)
                
                // Format task name for display
                if (taskName === 'thread') {
                    taskName = 'Thread Creation Task';
                } else if (taskName === 'reporting') {
                    taskName = 'Live Reporting Task';
                }
            }
        }
        
        // Parse timestamp from task info if available
        let scheduledTime = '';
        if (data && data.task_status && data.task_status.info) {
            try {
                if (typeof data.task_status.info === 'object') {
                    // Try to find ETA in the info object
                    if (data.task_status.info.eta) {
                        const date = new Date(data.task_status.info.eta);
                        scheduledTime = date.toLocaleString();
                    }
                } else {
                    // Fallback to regex for string info
                    const infoStr = String(data.task_status.info);
                    const timeMatch = infoStr.match(/(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2})/);
                    if (timeMatch && timeMatch[1]) {
                        const date = new Date(timeMatch[1]);
                        scheduledTime = date.toLocaleString();
                    }
                }
            } catch (e) {
                // Ignore parsing errors
            }
        }
        
        // Extract ETA from the original JSON data if available
        if (!scheduledTime && eta) {
            const etaDate = new Date(eta);
            scheduledTime = etaDate.toLocaleString();
        }
        
        tr.innerHTML = `
        <td>
            <div>
                <span class="fw-medium">${taskName || 'Task'}</span>
                <div>
                    <small class="text-muted d-block text-truncate" style="max-width: 200px;">${key}</small>
                    ${matchId ? `<small class="text-primary">Match ID: ${matchId}</small>` : ''}
                </div>
            </div>
        </td>
        <td>
            <span class="d-block text-truncate" style="max-width: 150px;">${taskId || 'N/A'}</span>
        </td>
        <td>
            <span class="badge bg-${getStatusColor(taskStatus)}">${taskStatus}</span>
        </td>
        <td>
            <div>
                ${countdownHtml}
                ${scheduledTime ? `<small class="d-block text-muted mt-1">Scheduled: ${scheduledTime}</small>` : ''}
            </div>
        </td>
        <td>
            <div class="btn-group">
                <button class="btn btn-sm btn-icon btn-danger" onclick="revokeTask('${taskId || ''}', '${key || ''}')" data-bs-toggle="tooltip" title="Revoke Task">
                    <i class="ti ti-trash"></i>
                </button>
                <button class="btn btn-sm btn-icon btn-warning ms-1" onclick="rescheduleTask('${taskId || ''}', '${key || ''}')" data-bs-toggle="tooltip" title="Reschedule Task">
                    <i class="ti ti-refresh"></i>
                </button>
            </div>
        </td>`;
        return tr;
    }

    // Update Redis status
    function updateRedisStatus(redis) {
        if (!redis) {
            redisConnectionStatus.className = 'badge bg-label-danger rounded-pill';
            redisConnectionStatus.textContent = 'Disconnected';
            return;
        }
        
        const status = redis.total > 0 ? 'Connected' : 'No Keys';
        const color = redis.total > 0 ? 'success' : 'warning';
        redisConnectionStatus.className = `badge bg-label-${color} rounded-pill`;
        redisConnectionStatus.textContent = status;
    }

    // Show error message
    function showError(message) {
        errorMessage.textContent = message;
        errorAlert.style.display = 'block';
    }

    // Task actions
    async function revokeTask(taskId, key) {
        if (!confirm('Are you sure you want to revoke this task?')) return;
        
        // Check if we have either taskId or key
        if (!taskId && !key) {
            showError('Cannot revoke task: Missing both task ID and key');
            return;
        }

        try {
            // Prepare payload - only include non-empty values
            const payload = {};
            if (taskId) payload.task_id = taskId;
            if (key) payload.key = key;
            
            console.log('Revoking task with payload:', payload);
            
            const response = await fetch('{{ url_for("monitoring.revoke_task") }}', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrfToken
                },
                body: JSON.stringify(payload)
            });

            const result = await response.json();

            if (response.ok && result.success) {
                await fetchData();  // Refresh data
            } else {
                throw new Error(result.error || 'Failed to revoke task');
            }
        } catch (err) {
            showError(err.message);
        }
    }

    async function rescheduleTask(taskId, key) {
        if (!confirm('Are you sure you want to reschedule this task?')) return;

        // Check if we have either taskId or key
        if (!taskId && !key) {
            showError('Cannot reschedule task: Missing both task ID and key');
            return;
        }

        try {
            // Prepare payload - only include non-empty values
            const payload = {};
            if (taskId) payload.task_id = taskId;
            if (key) payload.key = key;
            
            console.log('Rescheduling task with payload:', payload);
            
            const response = await fetch('{{ url_for("monitoring.reschedule_task") }}', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrfToken
                },
                body: JSON.stringify(payload)
            });

            const result = await response.json();

            if (response.ok && result.success) {
                await fetchData();  // Refresh data
            } else {
                throw new Error(result.error || 'Failed to reschedule task');
            }
        } catch (err) {
            showError(err.message);
        }
    }

    // Revoke All Tasks
    revokeAllButton.addEventListener('click', async () => {
        if (!confirm('Are you sure you want to revoke all tasks? This action cannot be undone.')) return;

        try {
            const response = await fetch('{{ url_for("monitoring.revoke_all_tasks") }}', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrfToken
                },
            });

            const result = await response.json();

            if (response.ok && result.success) {
                await fetchData();  // Refresh data
                alert(result.message);
            } else {
                throw new Error(result.error || 'Failed to revoke all tasks');
            }
        } catch (err) {
            showError(err.message);
        }
    });
    
    // Clean Orphaned Tasks button
    const cleanupOrphanedButton = document.getElementById('cleanupOrphanedButton');
    if (cleanupOrphanedButton) {
        cleanupOrphanedButton.addEventListener('click', async () => {
            if (!confirm('This will clean up any orphaned or inconsistent tasks. Continue?')) return;
            
            try {
                cleanupOrphanedButton.disabled = true;
                cleanupOrphanedButton.innerHTML = '<i class="ti ti-loader ti-spin me-1"></i>Cleaning...';
                
                const response = await fetch('{{ url_for("monitoring.cleanup_orphaned_tasks") }}', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                });
                
                const result = await response.json();
                
                if (response.ok && result.success) {
                    let message = 'Cleanup completed:\n';
                    message += `- ${result.cleaned_redis_keys} orphaned Redis keys removed\n`;
                    message += `- ${result.reset_matches} match statuses reset\n`;
                    
                    if (result.cleaned_redis_keys > 0 || result.reset_matches > 0) {
                        message += '\nThe system state has been corrected.';
                    } else {
                        message += '\nNo issues were found! The system is in a consistent state.';
                    }
                    
                    alert(message);
                    await fetchData();  // Refresh data
                } else {
                    throw new Error(result.error || 'Failed to clean up orphaned tasks');
                }
            } catch (err) {
                showError(err.message);
            } finally {
                cleanupOrphanedButton.disabled = false;
                cleanupOrphanedButton.innerHTML = '<i class="ti ti-robot me-1"></i>Clean Orphaned Tasks';
            }
        });
    }
    
    // Function to revoke all tasks for a specific worker
    async function revokeAllTasksForWorker(workerName) {
        if (!confirm(`Are you sure you want to revoke ALL tasks on worker "${workerName}"? This will remove ALL scheduled tasks for this worker.`)) {
            return;
        }
        
        try {
            // Call the revoke task endpoint with just the worker name
            const response = await fetch('{{ url_for("monitoring.revoke_task") }}', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrfToken
                },
                body: JSON.stringify({
                    worker: workerName
                })
            });
            
            const result = await response.json();
            
            if (response.ok && result.success) {
                alert(result.message || `All tasks on worker "${workerName}" have been revoked.`);
                await fetchData();  // Refresh data
            } else {
                throw new Error(result.error || 'Failed to revoke tasks');
            }
        } catch (err) {
            showError(err.message);
        }
    }
    
    // Function to show task details in a modal
    function showTaskDetails(taskDetailsJson) {
        let taskDetails;
        try {
            // Safely handle string input
            if (typeof taskDetailsJson === 'string') {
                // Handle empty or invalid input
                if (!taskDetailsJson || taskDetailsJson === '{}') {
                    taskDetails = { note: "No detailed task information available" };
                } else {
                    try {
                        taskDetails = JSON.parse(taskDetailsJson);
                    } catch (e) {
                        console.error("Error parsing JSON string:", e);
                        taskDetails = { 
                            error: "Could not parse task details",
                            raw: taskDetailsJson.substring(0, 500) + (taskDetailsJson.length > 500 ? '...' : '')
                        };
                    }
                }
            } else if (taskDetailsJson && typeof taskDetailsJson === 'object') {
                taskDetails = taskDetailsJson;
            } else {
                taskDetails = { note: "No detailed task information available" };
            }
        } catch (e) {
            console.error("Error processing task details:", e);
            taskDetails = { error: "Could not process task details" };
        }
        
        // Format the details as pretty JSON
        const formattedDetails = JSON.stringify(taskDetails, null, 2);
        
        // Create and show a modal with the details
        const modalId = "taskDetailsModal";
        
        // Remove any existing modal with this ID
        const existingModal = document.getElementById(modalId);
        if (existingModal) {
            existingModal.remove();
        }
        
        // Create new modal
        const modal = document.createElement('div');
        modal.id = modalId;
        modal.className = 'modal fade';
        modal.setAttribute('tabindex', '-1');
        modal.innerHTML = `
            <div class="modal-dialog modal-lg">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">Task Details</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <pre class="bg-dark text-light p-3 rounded" style="max-height: 400px; overflow-y: auto;">${formattedDetails}</pre>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                    </div>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        // Show the modal
        const modalInstance = new bootstrap.Modal(modal);
        modalInstance.show();
    }
    
    // Function to find and show match information
    function findMatch(matchId) {
        if (!matchId) {
            alert("No match ID provided");
            return;
        }
        
        // Redirect to the match view page
        window.location.href = `/match/${matchId}`;
    }

    // Refresh Button
    refreshButton.addEventListener('click', fetchData);

    // Initialize tooltips
    document.addEventListener('DOMContentLoaded', () => {
        const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
        tooltipTriggerList.map(function(tooltipTriggerEl) {
            return new bootstrap.Tooltip(tooltipTriggerEl, {
                delay: { show: 300, hide: 100 }
            });
        });
        
        // Initial fetch and setup refresh interval
        fetchData();
        setInterval(fetchData, 30000); // Refresh every 30 seconds
    });
</script>
{% endblock %}