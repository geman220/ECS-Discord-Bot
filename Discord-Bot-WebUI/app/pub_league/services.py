# app/pub_league/services.py

"""
Pub League Order Services

This module provides business logic for the Pub League order linking flow:
- PubLeagueOrderService: Order verification, linking, and pass management
- PlayerActivationService: Player status updates and activation
- RoleSyncService: Flask + Discord role synchronization
- ProfileConflictService: Detect and resolve profile conflicts
"""

import hashlib
import hmac
import logging
import re
from datetime import datetime, timedelta
from typing import Any, Optional

import requests
from flask import current_app, g, url_for

from app.core import db
from app.models import (
    Player, Role, Season, User, WalletPass,
    PubLeagueOrder, PubLeagueOrderLineItem, PubLeagueOrderClaim,
    PubLeagueOrderStatus, PubLeagueLineItemStatus, PubLeagueClaimStatus,
    create_pub_league_pass
)
from app.order_helpers import extract_jersey_size_from_product_name, extract_season_name

logger = logging.getLogger(__name__)


# Division to role mapping
DIVISION_ROLES = {
    'Classic': 'pl-classic',
    'Premier': 'pl-premier',
}

# Division to league ID mapping
DIVISION_LEAGUE_IDS = {
    'Classic': 11,
    'Premier': 10,
}


class PubLeagueOrderService:
    """
    Service for managing Pub League order linking.

    Handles order verification, fetching from WooCommerce,
    pass assignment, and claim link management.
    """

    @staticmethod
    def verify_order_token(order_id: int, token: str) -> bool:
        """
        Verify that the token matches the order.

        The token is generated by the WooCommerce plugin using HMAC-SHA256
        with a shared secret.

        Args:
            order_id: WooCommerce order ID
            token: Verification token from URL

        Returns:
            True if token is valid, False otherwise
        """
        secret = current_app.config.get('WALLET_WEBHOOK_SECRET', '')
        if not secret:
            logger.warning("WALLET_WEBHOOK_SECRET not configured")
            return False

        # Generate expected token
        message = f"pub_league_order_{order_id}"
        expected_token = hmac.new(
            secret.encode('utf-8'),
            message.encode('utf-8'),
            hashlib.sha256
        ).hexdigest()

        is_valid = hmac.compare_digest(token, expected_token)

        if not is_valid:
            logger.warning(
                f"Token verification failed for order {order_id}. "
                f"Received token: {token[:16]}... "
                f"Expected token: {expected_token[:16]}... "
                f"Secret configured: {bool(secret)} (length: {len(secret)})"
            )

        return is_valid

    @staticmethod
    def fetch_order_from_woocommerce(order_id: int) -> Optional[dict]:
        """
        Fetch order details from WooCommerce API.

        Args:
            order_id: WooCommerce order ID

        Returns:
            Order data dictionary or None if not found
        """
        try:
            from woocommerce import API

            wcapi = API(
                url=current_app.config['WOO_API_URL'],
                consumer_key=current_app.config['WOO_CONSUMER_KEY'],
                consumer_secret=current_app.config['WOO_CONSUMER_SECRET'],
                version="wc/v3"
            )

            response = wcapi.get(f"orders/{order_id}")
            response.raise_for_status()

            order_data = response.json()

            # Validate order status (must be paid)
            if order_data.get('status') not in ['processing', 'completed']:
                logger.warning(f"Order {order_id} has status {order_data.get('status')}, not valid for linking")
                return None

            return order_data

        except Exception as e:
            logger.error(f"Error fetching order {order_id} from WooCommerce: {e}")
            return None

    @staticmethod
    def extract_pub_league_items(order_data: dict) -> list[dict]:
        """
        Extract Pub League line items from WooCommerce order data.

        Filters for Pub League products and extracts division and jersey size.

        Args:
            order_data: WooCommerce order data

        Returns:
            List of extracted line item data
        """
        pub_league_items = []

        # Pattern to match Pub League products
        pub_league_pattern = re.compile(
            r'(\d{4})\s+(Spring|Fall)\s+ECS\s+Pub\s+League.*?(Classic|Premier)',
            re.IGNORECASE
        )
        alt_pattern = re.compile(
            r'(Spring|Fall)\s+(\d{4})\s+ECS\s+Pub\s+League.*?(Classic|Premier)',
            re.IGNORECASE
        )

        for item in order_data.get('line_items', []):
            product_name = item.get('name', '')
            quantity = item.get('quantity', 1)

            # Check if this is a Pub League product
            match = pub_league_pattern.search(product_name)
            if not match:
                match = alt_pattern.search(product_name)

            if match:
                # Extract division
                division = match.group(3).capitalize()

                # Extract jersey size from product name (last token after " - ")
                jersey_size = extract_jersey_size_from_product_name(product_name)
                if jersey_size == 'N/A':
                    jersey_size = None

                # Create one entry per quantity
                for _ in range(quantity):
                    pub_league_items.append({
                        'woo_line_item_id': item.get('id'),
                        'product_name': product_name,
                        'division': division,
                        'jersey_size': jersey_size,
                    })

        return pub_league_items

    @staticmethod
    def create_or_get_order(woo_order_id: int, order_data: dict) -> PubLeagueOrder:
        """
        Create a new PubLeagueOrder or return existing one.

        Args:
            woo_order_id: WooCommerce order ID
            order_data: WooCommerce order data

        Returns:
            PubLeagueOrder instance
        """
        # Check for existing order
        existing = PubLeagueOrder.find_by_woo_order_id(woo_order_id)
        if existing:
            return existing

        # Extract billing info
        billing = order_data.get('billing', {})
        customer_name = f"{billing.get('first_name', '')} {billing.get('last_name', '')}".strip()
        customer_email = billing.get('email', '')

        # Extract season from first Pub League item
        pub_league_items = PubLeagueOrderService.extract_pub_league_items(order_data)
        season_name = None
        if pub_league_items:
            season_name = extract_season_name(pub_league_items[0]['product_name'])

        # Find season in database
        season = None
        if season_name:
            session = getattr(g, 'db_session', db.session)
            season = session.query(Season).filter_by(name=season_name).first()

        # Create order
        order = PubLeagueOrder(
            woo_order_id=woo_order_id,
            verification_token=PubLeagueOrder.generate_verification_token(),
            customer_email=customer_email,
            customer_name=customer_name,
            season_name=season_name,
            season_id=season.id if season else None,
            total_passes=len(pub_league_items),
            woo_order_data=order_data,
            expires_at=datetime.utcnow() + timedelta(days=30)  # Order linking expires in 30 days
        )

        session = getattr(g, 'db_session', db.session)
        session.add(order)
        session.flush()  # Get the ID

        # Create line items
        for item_data in pub_league_items:
            line_item = PubLeagueOrderLineItem(
                order_id=order.id,
                woo_line_item_id=item_data['woo_line_item_id'],
                product_name=item_data['product_name'],
                division=item_data['division'],
                jersey_size=item_data['jersey_size'],
            )
            session.add(line_item)

        session.commit()
        return order

    @staticmethod
    def link_pass_to_player(line_item: PubLeagueOrderLineItem, player: Player, user: User = None) -> None:
        """
        Link a line item (pass) to a player.

        Args:
            line_item: PubLeagueOrderLineItem to assign
            player: Player to assign the pass to
            user: Optional User associated with the player
        """
        line_item.assign_to_player(player, user)

        session = getattr(g, 'db_session', db.session)
        session.commit()

        logger.info(f"Linked line item {line_item.id} to player {player.id} ({player.name})")

    @staticmethod
    def create_claim_link(
        order: PubLeagueOrder,
        line_item: PubLeagueOrderLineItem,
        created_by_user: User,
        recipient_email: str = None,
        recipient_name: str = None
    ) -> PubLeagueOrderClaim:
        """
        Create a claim link for an unassigned pass.

        Args:
            order: PubLeagueOrder
            line_item: PubLeagueOrderLineItem to create claim for
            created_by_user: User creating the claim link
            recipient_email: Optional email to send claim link to
            recipient_name: Optional name of recipient

        Returns:
            PubLeagueOrderClaim instance
        """
        claim = PubLeagueOrderClaim.create_claim(
            order=order,
            line_item=line_item,
            created_by_user=created_by_user,
            recipient_email=recipient_email,
            recipient_name=recipient_name,
            expiry_days=7
        )

        session = getattr(g, 'db_session', db.session)
        session.add(claim)
        session.commit()

        logger.info(f"Created claim link {claim.claim_token[:8]}... for line item {line_item.id}")
        return claim

    @staticmethod
    def process_claim(claim_token: str, player: Player, user: User) -> PubLeagueOrderLineItem:
        """
        Process a claim - assign the pass to the claiming player.

        Args:
            claim_token: The claim token from the URL
            player: Player claiming the pass
            user: User claiming the pass

        Returns:
            The assigned line item

        Raises:
            ValueError: If claim is invalid or expired
        """
        claim = PubLeagueOrderClaim.find_by_token(claim_token)
        if not claim:
            raise ValueError("Invalid claim link")

        if not claim.is_valid():
            raise ValueError("This claim link has expired or already been used")

        claim.process_claim(player, user)

        session = getattr(g, 'db_session', db.session)
        session.commit()

        logger.info(f"Claim {claim_token[:8]}... processed for player {player.id}")
        return claim.line_item

    @staticmethod
    def generate_wallet_pass_for_line_item(line_item: PubLeagueOrderLineItem) -> WalletPass:
        """
        Generate a wallet pass for an assigned line item.

        Args:
            line_item: The assigned line item

        Returns:
            WalletPass instance

        Raises:
            ValueError: If line item is not properly assigned
        """
        if not line_item.assigned_player_id:
            raise ValueError("Line item is not assigned to a player")

        player = line_item.assigned_player
        order = line_item.order
        season = order.season

        if not season:
            # Try to find season from season_name
            session = getattr(g, 'db_session', db.session)
            season = session.query(Season).filter_by(name=order.season_name).first()

        if not season:
            raise ValueError("Could not determine season for pass creation")

        # Create the pass
        wallet_pass = create_pub_league_pass(
            player=player,
            season=season,
            woo_order_id=order.woo_order_id
        )

        session = getattr(g, 'db_session', db.session)
        session.add(wallet_pass)
        session.flush()

        # Update line item
        line_item.mark_pass_created(wallet_pass)
        session.commit()

        logger.info(f"Created wallet pass {wallet_pass.id} for line item {line_item.id}")
        return wallet_pass


class PlayerActivationService:
    """
    Service for activating players after Pub League order linking.

    Handles setting is_current_player, updating league assignment,
    and coordinating role sync.
    """

    @staticmethod
    def activate_player_for_league(
        player: Player,
        user: User,
        division: str,
        jersey_size: str = None
    ) -> None:
        """
        Activate a player for a Pub League division.

        1. Set player.is_current_player = True
        2. Update player.jersey_size if provided (from conflict resolution)
        3. Update player.league_id based on division
        4. Sync roles (Flask + Discord) via RoleSyncService

        Args:
            player: Player to activate
            user: User associated with the player
            division: 'Classic' or 'Premier'
            jersey_size: Optional jersey size to update
        """
        session = getattr(g, 'db_session', db.session)

        # 1. Set is_current_player
        player.is_current_player = True

        # 2. Update jersey size if provided
        if jersey_size:
            player.jersey_size = jersey_size

        # 3. Update league assignment
        league_id = DIVISION_LEAGUE_IDS.get(division)
        if league_id:
            player.league_id = league_id
            player.primary_league_id = league_id

        session.commit()

        # 4. Sync roles (only if user is approved)
        if user.is_approved:
            RoleSyncService.sync_league_role(user, player, division)

        logger.info(f"Activated player {player.id} for {division} division")

    @staticmethod
    def check_profile_freshness(player: Player, days: int = 60) -> bool:
        """
        Check if player's profile was updated within the specified days.

        Args:
            player: Player to check
            days: Number of days to consider "fresh" (default 60)

        Returns:
            True if profile is fresh (updated within days), False otherwise
        """
        if not player.profile_last_updated:
            return False

        threshold = datetime.utcnow() - timedelta(days=days)
        return player.profile_last_updated > threshold


class RoleSyncService:
    """
    Service for syncing league roles in both Flask and Discord.

    ONLY manages pl-classic and pl-premier roles.
    All other roles (admin, coach, ref, team) are NEVER touched.
    """

    @staticmethod
    def sync_league_role(user: User, player: Player, new_division: str) -> None:
        """
        Sync league role in BOTH Flask and Discord.

        Only manages pl-classic and pl-premier roles.
        If switching leagues (Classic <-> Premier), removes old role and adds new.

        Args:
            user: User to update roles for
            player: Player associated with user (for Discord sync)
            new_division: 'Classic' or 'Premier'
        """
        new_role_name = DIVISION_ROLES.get(new_division)
        if not new_role_name:
            logger.warning(f"Unknown division: {new_division}")
            return

        opposite_division = 'Premier' if new_division == 'Classic' else 'Classic'
        opposite_role_name = DIVISION_ROLES.get(opposite_division)

        # 1. Flask role sync (database)
        RoleSyncService._sync_flask_role(user, new_role_name, opposite_role_name)

        # 2. Mark player for Discord role sync
        # The sync system reads Flask roles and maps them to Discord roles
        RoleSyncService._sync_discord_role(player)

    @staticmethod
    def _sync_flask_role(user: User, new_role_name: str, opposite_role_name: str) -> None:
        """
        Sync Flask roles in the database.

        Args:
            user: User to update
            new_role_name: Role to add (e.g., 'pl-classic')
            opposite_role_name: Role to remove if present (e.g., 'pl-premier')
        """
        session = getattr(g, 'db_session', db.session)

        # Get role objects
        new_role = session.query(Role).filter_by(name=new_role_name).first()
        opposite_role = session.query(Role).filter_by(name=opposite_role_name).first()

        # Add new role if not already present
        if new_role and new_role not in user.roles:
            user.roles.append(new_role)
            logger.info(f"Added Flask role {new_role_name} to user {user.id}")

        # Remove opposite role ONLY if they had it (league switch)
        if opposite_role and opposite_role in user.roles:
            user.roles.remove(opposite_role)
            logger.info(f"Removed Flask role {opposite_role_name} from user {user.id}")

        session.commit()

    @staticmethod
    def _sync_discord_role(player: Player) -> None:
        """
        Mark player for Discord role sync.

        The Discord role sync system reads Flask roles and syncs them to Discord.
        After updating Flask roles (in _sync_flask_role), we mark the player
        for update so the background sync job picks it up.

        Args:
            player: Player to mark for Discord update
        """
        try:
            if not player.discord_id:
                logger.warning(f"Player {player.id} has no Discord ID, skipping Discord role sync")
                return

            # Mark player for Discord update - the sync system will read
            # Flask roles (pl-classic, pl-premier) and map them to Discord roles
            # (ECS-FC-PL-CLASSIC, ECS-FC-PL-PREMIER)
            session = getattr(g, 'db_session', db.session)
            player.discord_needs_update = True
            session.commit()

            logger.info(f"Marked player {player.id} for Discord role sync")

        except Exception as e:
            logger.error(f"Error marking player {player.id} for Discord update: {e}")


class ProfileConflictService:
    """
    Service for detecting and resolving profile conflicts between
    WooCommerce order data and Flask portal profile.

    Portal is the GOLD STANDARD - order data is just a suggestion.
    """

    # Fields to compare for conflicts
    COMPARABLE_FIELDS = {
        'name': 'Name',
        'jersey_size': 'Jersey Size',
        # 'phone': 'Phone',  # Phone comparison requires decryption, skip for now
    }

    @staticmethod
    def detect_conflicts(player: Player, order_data: dict) -> list[dict]:
        """
        Compare order data with player profile to find conflicts.

        Portal is GOLD STANDARD - order data is just a suggestion.

        Args:
            player: Player to compare against
            order_data: WooCommerce order data (or extracted billing/item data)

        Returns:
            List of conflicts, each with:
            - field: Field name (e.g., 'jersey_size')
            - portal_value: Current value in portal
            - order_value: Value from order
            - display_name: Human-readable field name
        """
        conflicts = []
        order_fields = ProfileConflictService._get_comparable_order_fields(order_data)

        for field, display_name in ProfileConflictService.COMPARABLE_FIELDS.items():
            portal_value = getattr(player, field, None)
            order_value = order_fields.get(field)

            # Skip if either value is empty/None
            if not portal_value or not order_value:
                continue

            # Normalize for comparison
            portal_normalized = str(portal_value).strip().lower()
            order_normalized = str(order_value).strip().lower()

            # Check for mismatch
            if portal_normalized != order_normalized:
                conflicts.append({
                    'field': field,
                    'portal_value': portal_value,
                    'order_value': order_value,
                    'display_name': display_name,
                })

        return conflicts

    @staticmethod
    def _get_comparable_order_fields(order_data: dict) -> dict:
        """
        Extract comparable fields from WooCommerce order data.

        Args:
            order_data: WooCommerce order data

        Returns:
            Dictionary of field: value for comparison
        """
        fields = {}

        # Extract name from billing
        billing = order_data.get('billing', {})
        if billing:
            first_name = billing.get('first_name', '')
            last_name = billing.get('last_name', '')
            if first_name or last_name:
                fields['name'] = f"{first_name} {last_name}".strip()

        # Extract jersey size from line items (first Pub League item)
        for item in order_data.get('line_items', []):
            product_name = item.get('name', '')
            if 'Pub League' in product_name:
                jersey_size = extract_jersey_size_from_product_name(product_name)
                if jersey_size and jersey_size != 'N/A':
                    fields['jersey_size'] = jersey_size
                break

        return fields

    @staticmethod
    def resolve_conflict(
        player: Player,
        field: str,
        use_order_value: bool,
        order_value: Any
    ) -> None:
        """
        Apply user's resolution decision for a conflict.

        Args:
            player: Player to update
            field: Field name to potentially update
            use_order_value: True to update player with order value
            order_value: The value from the order
        """
        if not use_order_value:
            # Keep portal value - no action needed
            logger.info(f"Keeping portal value for {field} on player {player.id}")
            return

        # Update player with order value
        if hasattr(player, field):
            setattr(player, field, order_value)

            session = getattr(g, 'db_session', db.session)
            session.commit()

            logger.info(f"Updated player {player.id} {field} to {order_value} (from order)")

    @staticmethod
    def apply_resolutions(player: Player, resolutions: list[dict]) -> None:
        """
        Apply multiple conflict resolutions at once.

        Args:
            player: Player to update
            resolutions: List of resolution decisions, each with:
                - field: Field name
                - use_order_value: Boolean
                - order_value: Value to use if use_order_value is True
        """
        for resolution in resolutions:
            ProfileConflictService.resolve_conflict(
                player=player,
                field=resolution['field'],
                use_order_value=resolution.get('use_order_value', False),
                order_value=resolution.get('order_value')
            )


class ProductUrlService:
    """
    Service for generating WooCommerce product URLs for Pub League passes.

    URLs are constructed either from admin-configured slugs or auto-generated
    from the current season name.
    """

    @staticmethod
    def get_product_url(division: str, season_name: str = None) -> str:
        """
        Get the WooCommerce product URL for a division.

        Args:
            division: 'Classic' or 'Premier'
            season_name: Optional season name (e.g., 'Spring 2026'). If not provided,
                        will try to get current active season.

        Returns:
            Full product URL or None if not configured
        """
        from app.models import AdminConfig, Season

        # Get base shop URL
        shop_url = AdminConfig.get_setting('woocommerce_shop_url', 'https://weareecs.com')
        shop_url = shop_url.rstrip('/')

        # Try admin-configured slug first
        if division.lower() == 'premier':
            slug = AdminConfig.get_setting('pub_league_premier_product_slug', '')
        else:
            slug = AdminConfig.get_setting('pub_league_classic_product_slug', '')

        if slug:
            return f"{shop_url}/product/{slug}/"

        # Auto-generate slug from season name
        if not season_name:
            # Try to get current active season
            try:
                session = getattr(g, 'db_session', db.session)
                current_season = session.query(Season).filter_by(
                    is_current=True
                ).first()
                if current_season:
                    season_name = current_season.name
            except Exception:
                pass

        if season_name:
            # Convert "Spring 2026" or "2026 Spring" to "2026-spring"
            parts = season_name.split()
            if len(parts) == 2:
                if parts[0].isdigit():
                    year, season = parts[0], parts[1].lower()
                else:
                    season, year = parts[0].lower(), parts[1]
                slug = f"{year}-{season}-ecs-pub-league-{division.lower()}-division"
                return f"{shop_url}/product/{slug}/"

        return None

    @staticmethod
    def get_all_product_urls(season_name: str = None) -> dict:
        """
        Get product URLs for both divisions.

        Args:
            season_name: Optional season name

        Returns:
            Dict with 'premier' and 'classic' URLs
        """
        return {
            'premier': ProductUrlService.get_product_url('Premier', season_name),
            'classic': ProductUrlService.get_product_url('Classic', season_name),
        }


class UserSearchService:
    """
    Service for searching users to assign passes to.

    Searches by name, email, and Discord username.
    """

    @staticmethod
    def search_users(query: str, limit: int = 10) -> list[dict]:
        """
        Search for users by name, email, or Discord username.

        Args:
            query: Search query string
            limit: Maximum number of results

        Returns:
            List of user dictionaries with id, name, email_hint, discord_username
        """
        if not query or len(query) < 2:
            return []

        session = getattr(g, 'db_session', db.session)
        query_lower = query.lower()

        # Search players by name or Discord username
        players = session.query(Player).filter(
            db.or_(
                Player.name.ilike(f'%{query}%'),
                Player.discord_username.ilike(f'%{query}%')
            )
        ).limit(limit).all()

        results = []
        for player in players:
            # Get associated user
            user = player.user if player.user_id else None

            results.append({
                'player_id': player.id,
                'user_id': user.id if user else None,
                'name': player.name,
                'discord_username': player.discord_username,
                'email_hint': ProfileConflictService._mask_email(user.email) if user and hasattr(user, 'email') else None,
                'is_current_player': player.is_current_player,
            })

        return results

    @staticmethod
    def _mask_email(email: str) -> str:
        """
        Mask an email for display (e.g., j***@example.com).

        Args:
            email: Full email address

        Returns:
            Masked email string
        """
        if not email or '@' not in email:
            return None

        local, domain = email.split('@', 1)
        if len(local) <= 2:
            masked_local = local[0] + '*'
        else:
            masked_local = local[0] + '*' * (len(local) - 2) + local[-1]

        return f"{masked_local}@{domain}"
